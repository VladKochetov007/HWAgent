"""
Tool Manager - manages tool discovery, registration and execution.
Refactored to use core components and follow SOLID principles.
"""

import importlib
import inspect
import os
import subprocess
from typing import Any, Dict, List

from hwagent.core import (
    BaseTool, Constants, ToolExecutionResult, ToolDefinition,
    ConfigurationError, ToolExecutionError
)


class RunCommandTool(BaseTool):
    """Tool to execute a shell command with security restrictions."""
    name = "run_command"
    description = "Executes a shell command and returns its standard output and standard error. Use for tasks like compiling code, running scripts, etc. Commands are validated for security and dangerous operations are blocked."

    @property
    def parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "command": {
                    "type": "string",
                    "description": "The shell command to execute."
                }
            },
            "required": ["command"]
        }

    def __init__(self, tmp_directory: str = Constants.DEFAULT_TMP_DIRECTORY):
        super().__init__(tmp_directory)

    def _execute_impl(self, **kwargs: Any) -> ToolExecutionResult:
        command = kwargs.get("command")
        if not command:
            return ToolExecutionResult.error("Missing command parameter.", "'command' is required.")

        # Import SecurityValidator here to avoid circular imports
        from hwagent.core.validators import SecurityValidator
        
        # Security check for dangerous shell commands
        security_result = SecurityValidator.validate_shell_command_safety(command)
        if security_result.is_error():
            return ToolExecutionResult.error(
                f"Security check failed for command: {command}",
                security_result.details
            )

        try:
            # WARNING: shell=True can be a security risk if command is from untrusted input.
            # Here, it's assumed the command is generated by the agent itself.
            process = subprocess.run(
                command, 
                shell=True, 
                capture_output=True, 
                text=True, 
                timeout=60, # 60-second timeout
                check=False # Do not raise CalledProcessError for non-zero exit codes, handle manually
            )
            
            output = f"Exit Code: {process.returncode}\n"
            if process.stdout:
                output += f"Standard Output:\n{process.stdout}\n"
            if process.stderr:
                output += f"Standard Error:\n{process.stderr}\n"
            
            if process.returncode == 0:
                return ToolExecutionResult.success(output, "Command executed successfully.")
            else:
                return ToolExecutionResult.error(output, f"Command failed with exit code {process.returncode}.")

        except subprocess.TimeoutExpired:
            return ToolExecutionResult.error(
                "Command timed out after 60 seconds.", 
                "TimeoutExpired"
            )
        except Exception as e:
            return ToolExecutionResult.error(
                f"Error executing command '{command}': {str(e)}", 
                e.__class__.__name__
            )


class ToolDiscovery:
    """Handles tool discovery from the tools directory. Following SRP."""
    
    def __init__(self, tools_directory: str = Constants.TOOLS_DIR):
        self.tools_directory = tools_directory
    
    def discover_tools(self) -> List[type[BaseTool]]:
        """Discover all tool classes in the tools directory."""
        tool_classes = []
        
        if not os.path.exists(self.tools_directory):
            return tool_classes
        
        # Get all Python files in tools directory
        for filename in os.listdir(self.tools_directory):
            if filename.endswith("_tool.py") and not filename.startswith("__"):
                module_name = filename[:-3]  # Remove .py extension
                tool_class = self._load_tool_from_module(module_name)
                if tool_class:
                    tool_classes.append(tool_class)
        
        return tool_classes
    
    def _load_tool_from_module(self, module_name: str) -> type[BaseTool] | None:
        """Load tool class from module."""
        try:
            module_path = f"hwagent.tools.{module_name}"
            module = importlib.import_module(module_path)
            
            # Find BaseTool subclasses in the module
            for name, obj in inspect.getmembers(module, inspect.isclass):
                if (issubclass(obj, BaseTool) and 
                    obj is not BaseTool and 
                    obj.__module__ == module_path):
                    return obj
            
        except ImportError as e:
            print(f"Warning: Could not import tool module '{module_name}': {e}")
        except Exception as e:
            print(f"Warning: Error loading tool from '{module_name}': {e}")
        
        return None


class ToolRegistry:
    """Manages tool registration and retrieval. Following SRP."""
    
    def __init__(self):
        self._tools: Dict[str, BaseTool] = {}
        self._tool_definitions: Dict[str, ToolDefinition] = {}
    
    def register_tool(self, tool_instance: BaseTool) -> None:
        """Register a tool instance."""
        tool_name = tool_instance.name
        self._tools[tool_name] = tool_instance
        self._tool_definitions[tool_name] = tool_instance.get_tool_definition()
    
    def get_tool(self, tool_name: str) -> BaseTool | None:
        """Get tool instance by name."""
        return self._tools.get(tool_name)
    
    def get_tool_definition(self, tool_name: str) -> ToolDefinition | None:
        """Get tool definition by name."""
        return self._tool_definitions.get(tool_name)
    
    def get_all_tools(self) -> Dict[str, BaseTool]:
        """Get all registered tools."""
        return self._tools.copy()
    
    def get_all_tool_definitions(self) -> List[ToolDefinition]:
        """Get all tool definitions for API registration."""
        return list(self._tool_definitions.values())
    
    def get_tool_names(self) -> List[str]:
        """Get list of all tool names."""
        return list(self._tools.keys())


class ToolExecutionService:
    """Handles tool execution with proper error handling. Following SRP."""
    
    def __init__(self, tool_registry: ToolRegistry):
        self.tool_registry = tool_registry
    
    def execute_tool(self, tool_name: str, parameters: Dict[str, Any]) -> ToolExecutionResult:
        """Execute a tool with given parameters."""
        try:
            # Get tool instance
            tool = self.tool_registry.get_tool(tool_name)
            if not tool:
                return ToolExecutionResult.error(
                    f"Tool '{tool_name}' not found",
                    f"Available tools: {', '.join(self.tool_registry.get_tool_names())}"
                )
            
            # Execute tool
            result = tool.execute(**parameters)
            
            # Ensure we return a ToolExecutionResult
            if not isinstance(result, ToolExecutionResult):
                return ToolExecutionResult.error(
                    f"Tool '{tool_name}' returned invalid result type",
                    f"Expected ToolExecutionResult, got {type(result).__name__}"
                )
            
            return result
            
        except Exception as e:
            raise ToolExecutionError(tool_name, "Execution failed", str(e))


class ToolManager:
    """
    Main tool manager coordinating all tool operations.
    Following Facade pattern to provide simple interface.
    """
    
    def __init__(self, tmp_directory: str = Constants.DEFAULT_TMP_DIRECTORY):
        self.tmp_directory = tmp_directory
        self.discovery = ToolDiscovery()
        self.registry = ToolRegistry()
        self.execution_service = ToolExecutionService(self.registry)
        
        # Auto-discover and register tools
        self._initialize_tools()
    
    def _initialize_tools(self) -> None:
        """Initialize all tools by discovering and registering them."""
        try:
            # Discover tools from files
            tool_classes = self.discovery.discover_tools()
            
            for tool_class in tool_classes:
                try:
                    tool_instance = tool_class(tmp_directory=self.tmp_directory)
                    self.registry.register_tool(tool_instance)
                    print(f"Registered discovered tool: {tool_instance.name}")
                except Exception as e:
                    print(f"Warning: Failed to register tool {tool_class.__name__}: {e}")

            # Manually register built-in tools like RunCommandTool
            try:
                run_command_tool = RunCommandTool(tmp_directory=self.tmp_directory)
                self.registry.register_tool(run_command_tool)
                print(f"Registered built-in tool: {run_command_tool.name}")
            except Exception as e:
                print(f"Warning: Failed to register built-in RunCommandTool: {e}")
            
            if not self.registry.get_tool_names():
                print("Warning: No tools were successfully registered. Tool functionality will be limited.")
                
        except Exception as e:
            print(f"Error during tool initialization process: {e}")
    
    def execute_tool(self, tool_name: str, parameters: Dict[str, Any]) -> str:
        """
        Execute a tool and return formatted result.
        This method maintains backward compatibility with the old interface.
        """
        try:
            result = self.execution_service.execute_tool(tool_name, parameters)
            return result.to_string()
        except ToolExecutionError as e:
            return str(e)
        except Exception as e:
            return f"Error: Unexpected error executing tool '{tool_name}': {e}"
    
    def get_tools_for_llm(self) -> List[Dict[str, Any]]:
        """Get tool definitions formatted for LLM API."""
        return [
            definition.to_api_format() 
            for definition in self.registry.get_all_tool_definitions()
        ]
    
    def get_tool_names(self) -> List[str]:
        """Get list of available tool names."""
        return self.registry.get_tool_names()
    
    def get_tool_count(self) -> int:
        """Get number of registered tools."""
        return len(self.registry.get_tool_names())
    
    def get_tool_definitions_for_prompt(self) -> str:
        """Get tool definitions formatted for text prompt (backward compatibility)."""
        definitions = []
        for definition in self.registry.get_all_tool_definitions():
            tool_def = f"- {definition.name}: {definition.description}"
            if definition.parameters:
                params = ", ".join([f"{name}: {param.get('description', 'No description')}" 
                                  for name, param in definition.parameters.get('properties', {}).items()])
                tool_def += f" (Parameters: {params})"
            definitions.append(tool_def)
        return "\n".join(definitions)
    
    def get_tools_for_api(self) -> List[Dict[str, Any]]:
        """Get tool definitions for API (backward compatibility alias)."""
        return self.get_tools_for_llm()
    
    def reload_tools(self) -> None:
        """Reload all tools (useful for development)."""
        # Clear current registry
        self.registry = ToolRegistry()
        self.execution_service = ToolExecutionService(self.registry)
        
        # Re-initialize tools
        self._initialize_tools() 